import { availableLangs } from "@vot.js/shared/consts";
import { normalizeLang } from "@vot.js/shared/utils/utils";

import debug from "./debug.ts";
import { localizationProvider } from "../localization/localizationProvider.js";
import { cleanText } from "./utils.js";
import { detect } from "./translateApis.ts";

// Get the language code from the response or the text
async function getLanguage(player, response, title, description) {
  if (
    !window.location.hostname.includes("m.youtube.com") &&
    player?.getAudioTrack
  ) {
    // Experimental: Get language from selected audio track if available
    const trackInfo = player.getAudioTrack()?.getLanguageInfo(); // Get selected track info
    if (trackInfo?.id !== "und") {
      return normalizeLang(trackInfo.id.split(".")[0]);
    }

    // Get available audio tracks
    const audioTracks = player.getAvailableAudioTracks();
    // Find automatic caption track in audio tracks
    const autoCaption = audioTracks?.find(
      (track) => track.kind === "asr" && track.languageCode,
    );
    if (autoCaption) {
      return normalizeLang(autoCaption.languageCode);
    }
  }

  // If there is no caption track, use detect to get the language code from the description
  const autoCaption =
    response?.captions?.playerCaptionsTracklistRenderer?.captionTracks?.find(
      (caption) => caption.kind === "asr" && caption.languageCode,
    );
  if (autoCaption) {
    return normalizeLang(autoCaption.languageCode);
  }

  // Use the description text to detect the language if no captions are available
  const text = cleanText(title, description);

  debug.log(`Detecting language text: ${text}`);

  return detect(text);
}

function isMobile() {
  return /^m\.youtube\.com$/.test(window.location.hostname);
}

function getPlayer() {
  if (window.location.pathname.startsWith("/shorts/") && !isMobile()) {
    return document.querySelector("#shorts-player");
  }

  return document.querySelector("#movie_player");
}

function getPlayerResponse() {
  const player = getPlayer();
  if (player?.getPlayerResponse)
    return player?.getPlayerResponse?.call() ?? null;
  return player?.data?.playerResponse ?? null;
}

function getPlayerData() {
  const player = getPlayer();
  if (player?.getVideoData) return player?.getVideoData?.call() ?? null;
  return player?.data?.playerResponse?.videoDetails ?? null;
}

function getVideoVolume() {
  const player = getPlayer();
  if (player?.getVolume) {
    return player.getVolume.call() / 100;
  }

  return 1;
}

function setVideoVolume(volume) {
  const player = getPlayer();
  if (player?.setVolume) {
    player.setVolume(Math.round(volume * 100));
    return true;
  }
}

function isMuted() {
  const player = getPlayer();
  if (player?.isMuted) {
    return player.isMuted.call();
  }

  return false;
}

function videoSeek(video, time) {
  // * TIME IN MS
  debug.log("videoSeek", time);
  const preTime =
    getPlayer()?.getProgressState()?.seekableEnd || video.currentTime;
  const finalTime = preTime - time; // we always throw it to the end of the stream - time
  video.currentTime = finalTime;
}

function getSubtitles(responseLang = localizationProvider.lang) {
  const response = getPlayerResponse();
  const playerCaptions = response?.captions?.playerCaptionsTracklistRenderer;
  if (!playerCaptions) {
    return [];
  }

  let captionTracks = playerCaptions.captionTracks ?? [];
  const translationLanguages = playerCaptions.translationLanguages ?? [];
  const userLangSupported = translationLanguages.find(
    (language) => language.languageCode === responseLang,
  );
  const asrLang =
    captionTracks.find((captionTrack) => captionTrack?.kind === "asr")
      ?.languageCode ?? "en";
  captionTracks = captionTracks.reduce((result, captionTrack) => {
    if (!("languageCode" in captionTrack)) {
      return result;
    }

    const language = captionTrack.languageCode
      ? normalizeLang(captionTrack.languageCode)
      : undefined;
    const url = captionTrack?.url || captionTrack?.baseUrl;
    if (!language || !url) {
      return result;
    }

    const captionUrl = `${
      url.startsWith("http") ? url : `${window.location.origin}/${url}`
    }&fmt=json3`;
    result.push({
      source: "youtube",
      format: "json",
      language,
      isAutoGenerated: captionTrack?.kind === "asr",
      url: captionUrl,
    });

    if (
      userLangSupported &&
      captionTrack.isTranslatable &&
      captionTrack.languageCode === asrLang &&
      responseLang !== language
    ) {
      // add translated youtube subtitles (if it possible)
      result.push({
        source: "youtube",
        format: "json",
        language: responseLang,
        isAutoGenerated: captionTrack?.kind === "asr",
        translatedFromLanguage: language,
        url: `${captionUrl}&tlang=${responseLang}`,
      });
    }

    return result;
  }, []);
  debug.log("youtube subtitles:", captionTracks);
  return captionTracks;
}

// Get the video data from the player
async function getVideoData() {
  const player = getPlayer();
  const response = getPlayerResponse();
  const data = getPlayerData();
  const { title: localizedTitle } = data ?? {};
  const {
    shortDescription: description,
    isLive,
    title,
  } = response?.videoDetails ?? {};
  let detectedLanguage = title
    ? await getLanguage(player, response, title, description)
    : "en";
  detectedLanguage = availableLangs.includes(detectedLanguage)
    ? detectedLanguage
    : "en";
  const videoData = {
    isLive: !!isLive,
    title,
    localizedTitle,
    description,
    detectedLanguage,
  };
  debug.log("youtube video data:", videoData);
  console.log("[VOT] Detected language: ", videoData.detectedLanguage);
  return videoData;
}

export default {
  isMobile,
  getPlayer,
  getPlayerResponse,
  getPlayerData,
  getVideoVolume,
  getSubtitles,
  getVideoData,
  setVideoVolume,
  videoSeek,
  isMuted,
};
